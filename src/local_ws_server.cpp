// local_ws_server.cpp
#include "local_ws_server.hpp"
#include "executors/cuda_executor.hpp"
#include "executors/opencl_executor.hpp"
#include "executors/vulkan_executor.hpp"
#include "base64.hpp"
#include <boost/beast/core.hpp>
#include <boost/beast/websocket.hpp>
#include <boost/beast/ssl.hpp>
#include <boost/asio/ip/tcp.hpp>
#include <boost/asio/ssl.hpp>
#include <boost/asio/error.hpp>
#include <iostream>
#include <fstream>
#include <thread>
#include <chrono>

using tcp = boost::asio::ip::tcp;
namespace websocket = boost::beast::websocket;
namespace beast = boost::beast;
namespace ssl = boost::asio::ssl;

LocalWSServer::LocalWSServer(){}
LocalWSServer::~LocalWSServer(){ stop(); }

bool LocalWSServer::start(const std::string& address, unsigned short port,
                         const std::string& target, bool use_ssl){
    if(running) return false;
    running=true;
    th = std::thread(&LocalWSServer::run, this, address, port, target, use_ssl);
    return true;
}

void LocalWSServer::stop(){
    running=false;
    if(th.joinable()) th.join();
}

void LocalWSServer::run(const std::string& address, unsigned short port,
                       const std::string& target, bool use_ssl){
    if(use_ssl) {
        run_ssl(address, port, target);
    } else {
        run_plain(address, port, target);
    }
}

// Helper: treat these errors as normal client disconnects (not server fatal)
static bool is_normal_disconnect(const boost::system::error_code& ec){
    if(!ec) return false;
    return ec == boost::asio::error::eof
        || ec == boost::asio::error::connection_reset
        || ec == boost::asio::error::connection_aborted
        || ec == boost::asio::ssl::error::stream_truncated;
}

void LocalWSServer::run_ssl(const std::string& address, unsigned short port, const std::string& target){
    try{
        boost::asio::io_context ioc;

        // SSL context setup
        ssl::context ctx{ssl::context::tlsv12_server};

        // Load certificate and private key
        // These will be generated by our script
        ctx.use_certificate_chain_file("server.crt");
        ctx.use_private_key_file("server.key", ssl::context::pem);

        // Optional: set up DH parameters for better security
        // ctx.use_tmp_dh_file("dh2048.pem");

        tcp::endpoint endpoint{boost::asio::ip::make_address(address), port};
        tcp::acceptor acceptor{ioc};
        boost::system::error_code ec;
        acceptor.open(endpoint.protocol(), ec);
        if(ec){
            std::cerr << "[local-ws] acceptor.open error: " << ec.message() << std::endl;
            return;
        }
        acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);
        if(ec){
            std::cerr << "[local-ws] setting reuse_address failed: " << ec.message() << std::endl;
        }
        acceptor.bind(endpoint, ec);
        if(ec){
            std::cerr << "[local-ws] bind error: " << ec.message() << std::endl;
            return;
        }
        acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
        if(ec){
            std::cerr << "[local-ws] listen error: " << ec.message() << std::endl;
            return;
        }

        std::cout << "[local-ws] SSL WebSocket server listening on wss://" << address << ":" << port << target << std::endl;
        std::cout << "[local-ws] Using self-signed certificate (server.crt)" << std::endl;

        // Accept loop - robust: errors per-connection are handled locally and loop continues
        while(running){
            tcp::socket socket{ioc};
            boost::system::error_code accept_ec;
            acceptor.accept(socket, accept_ec);
            if(accept_ec){
                // log and continue accepting
                if(running) std::cerr << "[local-ws] accept error: " << accept_ec.message() << std::endl;
                // small sleep to avoid tight loop on persistent accept errors
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                continue;
            }

            // Handle connection in synchronous style but with non-throwing operations
            try{
                // Move socket into an ssl stream
                ssl::stream<tcp::socket> ssl_socket{std::move(socket), ctx};

                // Perform SSL handshake (non-throwing)
                boost::system::error_code hs_ec;
                ssl_socket.handshake(ssl::stream_base::server, hs_ec);
                if(hs_ec){
                    if(is_normal_disconnect(hs_ec)){
                        // client disconnected during handshake; just continue
                        if(running) std::cerr << "[local-ws] SSL handshake aborted by client: " << hs_ec.message() << std::endl;
                    } else {
                        std::cerr << "[local-ws] SSL handshake error: " << hs_ec.message() << std::endl;
                    }
                    // Ensure socket is closed and continue accepting
                    boost::system::error_code close_ec;
                    ssl_socket.lowest_layer().close(close_ec);
                    continue;
                }

                // Create WebSocket over SSL stream (use reference to ssl_socket)
                websocket::stream<ssl::stream<tcp::socket>&> ws{ssl_socket};

                // Accept the websocket handshake (non-throwing)
                boost::system::error_code ws_accept_ec;
                ws.accept(ws_accept_ec);
                if(ws_accept_ec){
                    if(is_normal_disconnect(ws_accept_ec)){
                        if(running) std::cerr << "[local-ws] WebSocket accept aborted by client: " << ws_accept_ec.message() << std::endl;
                    } else {
                        std::cerr << "[local-ws] WebSocket accept error: " << ws_accept_ec.message() << std::endl;
                    }
                    boost::system::error_code close_ec;
                    ssl_socket.lowest_layer().close(close_ec);
                    continue;
                }

                // Read a single message (non-throwing)
                beast::flat_buffer buffer;
                boost::system::error_code read_ec;
                ws.read(buffer, read_ec);
                if(read_ec){
                    if(is_normal_disconnect(read_ec)){
                        if(running) std::cerr << "[local-ws] client disconnected (read): " << read_ec.message() << std::endl;
                    } else {
                        std::cerr << "[local-ws] WebSocket read error: " << read_ec.message() << std::endl;
                    }
                    boost::system::error_code close_ec;
                    ws.next_layer().lowest_layer().close(close_ec);
                    continue;
                }

                std::string s = beast::buffers_to_string(buffer.data());
                buffer.clear();

                std::cerr << "[local-ws] Received request: " << s.substr(0, 500) << (s.length() > 500 ? "..." : "") << std::endl;

                nlohmann::json req = nlohmann::json::parse(s, nullptr, false);
                nlohmann::json resp;

                if(req.is_discarded() || req.value("action","")!="compile_and_run"){
                    resp = {{"ok",false},{"error","invalid request"}};
                } else {
                    std::string framework = req.value("framework","cuda");
                    if(framework!="cuda" && framework!="opencl" && framework!="vulkan"){
                        resp = {{"ok",false},{"error","framework must be cuda|opencl|vulkan"}};
                    } else if(framework=="cuda"){
                    #ifdef HAVE_CUDA
                        CudaExecutor exec(0);
                        if(!exec.initialize(nlohmann::json::object())){
                            resp = {{"ok",false},{"error","cuda init failed"}};
                        } else {
                            std::cerr << "[local-ws] OpenCL initialized, running task..." << std::endl;
                            auto result = exec.run_task(req);
                            if(result.ok){
                                std::cerr << "[local-ws] OpenCL task completed successfully" << std::endl;
                                nlohmann::json outs = nlohmann::json::array();
                                for(auto& o: result.outputs) outs.push_back(base64_encode(o));
                                resp = {{"ok",true},{"outputs",outs},{"processingTimeMs",result.ms}};
                            } else {
                                std::cerr << "[local-ws] OpenCL task failed: " << result.error << std::endl;
                                resp = {{"ok",false},{"error",result.error}};
                            }
                        }
                    #else
                        resp = {{"ok",false},{"error","cuda disabled at build time"}};
                    #endif
                    } else if(framework=="opencl"){
                    #ifdef HAVE_OPENCL
                        std::cerr << "[local-ws] Creating OpenCL executor..." << std::endl;
                        OpenCLExecutor exec;
                        if(!exec.initialize(nlohmann::json::object())){
                            std::cerr << "[local-ws] OpenCL initialization failed" << std::endl;
                            resp = {{"ok",false},{"error","opencl init failed"}};
                        } else {
                            std::cerr << "[local-ws] OpenCL initialized, running task..." << std::endl;
                            auto result = exec.run_task(req);
                            if(result.ok){
                                std::cerr << "[local-ws] OpenCL task completed successfully" << std::endl;
                                nlohmann::json outs = nlohmann::json::array();
                                for(auto& o: result.outputs) outs.push_back(base64_encode(o));
                                resp = {{"ok",true},{"outputs",outs},{"processingTimeMs",result.ms}};
                            } else {
                                std::cerr << "[local-ws] OpenCL task failed: " << result.error << std::endl;
                                resp = {{"ok",false},{"error",result.error}};
                            }
                        }
                    #else
                        resp = {{"ok",false},{"error","opencl disabled at build time"}};
                    #endif
                    } else if(framework=="vulkan"){
                    #ifdef HAVE_VULKAN
                        VulkanExecutor exec;
                        if(!exec.initialize(nlohmann::json::object())){
                            resp = {{"ok",false},{"error","vulkan init failed"}};
                        } else {
                            std::cerr << "[local-ws] OpenCL initialized, running task..." << std::endl;
                            auto result = exec.run_task(req);
                            if(result.ok){
                                std::cerr << "[local-ws] OpenCL task completed successfully" << std::endl;
                                nlohmann::json outs = nlohmann::json::array();
                                for(auto& o: result.outputs) outs.push_back(base64_encode(o));
                                resp = {{"ok",true},{"outputs",outs},{"processingTimeMs",result.ms}};
                            } else {
                                std::cerr << "[local-ws] OpenCL task failed: " << result.error << std::endl;
                                resp = {{"ok",false},{"error",result.error}};
                            }
                        }
                    #else
                        resp = {{"ok",false},{"error","vulkan disabled at build time"}};
                    #endif
                    }
                }

                auto out = resp.dump();
                ws.text(true);
                boost::system::error_code write_ec;
                ws.write(boost::asio::buffer(out), write_ec);
                if(write_ec){
                    if(is_normal_disconnect(write_ec)){
                        if(running) std::cerr << "[local-ws] client disconnected (write): " << write_ec.message() << std::endl;
                    } else {
                        std::cerr << "[local-ws] WebSocket write error: " << write_ec.message() << std::endl;
                    }
                    // proceed to cleanup
                }

                // Graceful shutdown of websocket/ssl: try clean shutdown, but ignore truncated/EOF
                boost::system::error_code shutdown_ec;
                // For websocket over SSL, close the websocket first
                ws.close(websocket::close_code::normal, shutdown_ec);
                if(shutdown_ec && !is_normal_disconnect(shutdown_ec)){
                    std::cerr << "[local-ws] WebSocket close error: " << shutdown_ec.message() << std::endl;
                }
                // Only try TLS shutdown if socket is open
                boost::system::error_code ssl_shutdown_ec;
                if (ssl_socket.lowest_layer().is_open()) {
                    ssl_socket.shutdown(ssl_shutdown_ec);
                    if (ssl_shutdown_ec && !is_normal_disconnect(ssl_shutdown_ec) && ssl_shutdown_ec.value() != EBADF) {
                        std::cerr << "[local-ws] SSL shutdown error: " << ssl_shutdown_ec.message() << std::endl;
                    }
                } // else: underlying socket already closed, skip
                // ensure underlying socket closed
                boost::system::error_code close_ec;
                ssl_socket.lowest_layer().close(close_ec);

            }catch(std::exception const& e){
                // This catch is defensive: ideally we use non-throwing APIs above.
                if(running) std::cerr << "[local-ws] connection handler exception: " << e.what() << std::endl;
                // Continue accepting next connection regardless
            }
        } // end while(running)

    }catch(std::exception const& e){
        if(running) std::cerr << "[local-ws] SSL server fatal error: " << e.what() << std::endl;
    }
}

void LocalWSServer::run_plain(const std::string& address, unsigned short port, const std::string& target){
    try{
        boost::asio::io_context ioc;
        tcp::endpoint endpoint{boost::asio::ip::make_address(address), port};
        tcp::acceptor acceptor{ioc};
        boost::system::error_code ec;
        acceptor.open(endpoint.protocol(), ec);
        if(ec){
            std::cerr << "[local-ws] acceptor.open error: " << ec.message() << std::endl;
            return;
        }
        acceptor.set_option(boost::asio::socket_base::reuse_address(true), ec);
        if(ec){
            std::cerr << "[local-ws] setting reuse_address failed: " << ec.message() << std::endl;
        }
        acceptor.bind(endpoint, ec);
        if(ec){
            std::cerr << "[local-ws] bind error: " << ec.message() << std::endl;
            return;
        }
        acceptor.listen(boost::asio::socket_base::max_listen_connections, ec);
        if(ec){
            std::cerr << "[local-ws] listen error: " << ec.message() << std::endl;
            return;
        }

        std::cout << "[local-ws] Plain WebSocket server listening on ws://" << address << ":" << port << target << std::endl;

        while(running){
            tcp::socket socket{ioc};
            boost::system::error_code accept_ec;
            acceptor.accept(socket, accept_ec);
            if(accept_ec){
                if(running) std::cerr << "[local-ws] accept error: " << accept_ec.message() << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                continue;
            }

            try{
                websocket::stream<tcp::socket> ws{std::move(socket)};
                boost::system::error_code ws_accept_ec;
                ws.accept(ws_accept_ec);
                if(ws_accept_ec){
                    if(is_normal_disconnect(ws_accept_ec)){
                        if(running) std::cerr << "[local-ws] WebSocket accept aborted by client: " << ws_accept_ec.message() << std::endl;
                    } else {
                        std::cerr << "[local-ws] WebSocket accept error: " << ws_accept_ec.message() << std::endl;
                    }
                    ws.next_layer().close();
                    continue;
                }

                beast::flat_buffer buffer;
                boost::system::error_code read_ec;
                ws.read(buffer, read_ec);
                if(read_ec){
                    if(is_normal_disconnect(read_ec)){
                        if(running) std::cerr << "[local-ws] client disconnected (read): " << read_ec.message() << std::endl;
                    } else {
                        std::cerr << "[local-ws] WebSocket read error: " << read_ec.message() << std::endl;
                    }
                    boost::system::error_code close_ec;
                    ws.next_layer().close(close_ec);
                    continue;
                }

                std::string s = beast::buffers_to_string(buffer.data());
                buffer.clear();

                nlohmann::json req = nlohmann::json::parse(s, nullptr, false);
                nlohmann::json resp;

                if(req.is_discarded() || req.value("action","")!="compile_and_run"){
                    resp = {{"ok",false},{"error","invalid request"}};
                } else {
                    std::string framework = req.value("framework","cuda");
                    if(framework!="cuda" && framework!="opencl" && framework!="vulkan"){
                        resp = {{"ok",false},{"error","framework must be cuda|opencl|vulkan"}};
                    } else if(framework=="cuda"){
                    #ifdef HAVE_CUDA
                        CudaExecutor exec(0);
                        if(!exec.initialize(nlohmann::json::object())){
                            resp = {{"ok",false},{"error","cuda init failed"}};
                        } else {
                            std::cerr << "[local-ws] OpenCL initialized, running task..." << std::endl;
                            auto result = exec.run_task(req);
                            if(result.ok){
                                std::cerr << "[local-ws] OpenCL task completed successfully" << std::endl;
                                nlohmann::json outs = nlohmann::json::array();
                                for(auto& o: result.outputs) outs.push_back(base64_encode(o));
                                resp = {{"ok",true},{"outputs",outs},{"processingTimeMs",result.ms}};
                            } else {
                                std::cerr << "[local-ws] OpenCL task failed: " << result.error << std::endl;
                                resp = {{"ok",false},{"error",result.error}};
                            }
                        }
                    #else
                        resp = {{"ok",false},{"error","cuda disabled at build time"}};
                    #endif
                    } else if(framework=="opencl"){
                    #ifdef HAVE_OPENCL
                        std::cerr << "[local-ws] Creating OpenCL executor..." << std::endl;
                        OpenCLExecutor exec;
                        if(!exec.initialize(nlohmann::json::object())){
                            std::cerr << "[local-ws] OpenCL initialization failed" << std::endl;
                            resp = {{"ok",false},{"error","opencl init failed"}};
                        } else {
                            std::cerr << "[local-ws] OpenCL initialized, running task..." << std::endl;
                            auto result = exec.run_task(req);
                            if(result.ok){
                                std::cerr << "[local-ws] OpenCL task completed successfully" << std::endl;
                                nlohmann::json outs = nlohmann::json::array();
                                for(auto& o: result.outputs) outs.push_back(base64_encode(o));
                                resp = {{"ok",true},{"outputs",outs},{"processingTimeMs",result.ms}};
                            } else {
                                std::cerr << "[local-ws] OpenCL task failed: " << result.error << std::endl;
                                resp = {{"ok",false},{"error",result.error}};
                            }
                        }
                    #else
                        resp = {{"ok",false},{"error","opencl disabled at build time"}};
                    #endif
                    } else if(framework=="vulkan"){
                    #ifdef HAVE_VULKAN
                        VulkanExecutor exec;
                        if(!exec.initialize(nlohmann::json::object())){
                            resp = {{"ok",false},{"error","vulkan init failed"}};
                        } else {
                            std::cerr << "[local-ws] OpenCL initialized, running task..." << std::endl;
                            auto result = exec.run_task(req);
                            if(result.ok){
                                std::cerr << "[local-ws] OpenCL task completed successfully" << std::endl;
                                nlohmann::json outs = nlohmann::json::array();
                                for(auto& o: result.outputs) outs.push_back(base64_encode(o));
                                resp = {{"ok",true},{"outputs",outs},{"processingTimeMs",result.ms}};
                            } else {
                                std::cerr << "[local-ws] OpenCL task failed: " << result.error << std::endl;
                                resp = {{"ok",false},{"error",result.error}};
                            }
                        }
                    #else
                        resp = {{"ok",false},{"error","vulkan disabled at build time"}};
                    #endif
                    }
                }

                auto out = resp.dump();
                ws.text(true);
                boost::system::error_code write_ec;
                ws.write(boost::asio::buffer(out), write_ec);
                if(write_ec){
                    if(is_normal_disconnect(write_ec)){
                        if(running) std::cerr << "[local-ws] client disconnected (write): " << write_ec.message() << std::endl;
                    } else {
                        std::cerr << "[local-ws] WebSocket write error: " << write_ec.message() << std::endl;
                    }
                }

                // Close websocket gracefully (ignore normal disconnects)
                boost::system::error_code close_ec;
                ws.close(websocket::close_code::normal, close_ec);
                if(close_ec && !is_normal_disconnect(close_ec)){
                    std::cerr << "[local-ws] WebSocket close error: " << close_ec.message() << std::endl;
                }
                boost::system::error_code underlying_close_ec;
                ws.next_layer().close(underlying_close_ec);

            }catch(std::exception const& e){
                if(running) std::cerr << "[local-ws] connection handler exception (plain): " << e.what() << std::endl;
            }
        }

    }catch(std::exception const& e){
        if(running) std::cerr << "[local-ws] error: " << e.what() << std::endl;
    }
}
